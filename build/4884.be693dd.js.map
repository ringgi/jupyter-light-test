{"version":3,"file":"4884.be693dd.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JS = 'application/javascript';\n    MIME.JSON = 'application/json';\n    MIME.MANIFEST_JSON = 'application/manifest+json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.PYTHON = 'application/x-python-code';\n    MIME.SVG = 'image/svg+xml';\n    MIME.XML = 'application/xml';\n    /**\n     * A list of mime types of common text file types\n     */\n    MIME.KNOWN_TEXT_TYPES = new Set([MIME.JSON, MIME.JS, MIME.MANIFEST_JSON, MIME.PYTHON, MIME.XML, MIME.SVG]);\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport localforage from 'localforage';\nimport { MIME } from './tokens';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageName = (options || {}).contentsStorageName || DEFAULT_STORAGE_NAME;\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            version: 1,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            version: 1,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return localforage.createInstance({\n            name: this._storageName,\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            version: 1,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: undefined,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'file': {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'text',\n                    // TODO: handle mimetypes\n                    mimetype: MIME.PLAIN_TEXT,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n            default: {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await this._storage.setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await this._storage.setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const item = await this._storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: undefined,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await this._storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: undefined,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        await this._storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await this._storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await this._checkpoints.removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        let item = (await this.get(path)) || (await this.newUntitled({ path }));\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        if (options.content && options.format === 'base64') {\n            // TODO: keep base64 if not a text file (image)\n            const content = decodeURIComponent(escape(atob(options.content)));\n            const nb = ext === '.ipynb';\n            item = {\n                ...item,\n                content: nb ? JSON.parse(content) : content,\n                format: nb ? 'json' : 'text',\n                type: nb ? 'notebook' : 'file',\n            };\n        }\n        await this._storage.setItem(path, item);\n        return item;\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await this._storage.keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            this._storage.removeItem(path),\n            this._checkpoints.removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await this._checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await this._checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await this._checkpoints.getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await this._checkpoints.getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await this._storage.setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await this._checkpoints.getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await this._checkpoints.setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        await this._storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: undefined,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            content: null,\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                if (model.type === 'notebook' ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                    };\n                }\n                else if (mimetype.indexOf('text') !== -1 ||\n                    MIME.KNOWN_TEXT_TYPES.has(mimetype)) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(new Uint8Array(await response.arrayBuffer()).reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. if there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const current = (_a = (await this._counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await this._counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { Contents, IContents } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    autoStart: true,\n    provides: IContents,\n    activate: (app) => {\n        const contentsStorageName = PageConfig.getOption('contentsStorageName');\n        return new Contents({ contentsStorageName });\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs({});\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const res = kernelspecs.specs;\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    provides: ISettings,\n    activate: (app) => {\n        const settingsStorageName = PageConfig.getOption('settingsStorageName');\n        return new Settings({ settingsStorageName });\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    nbconvertRoutesPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n"],"names":["IContents","Token","MIME","JS","JSON","MANIFEST_JSON","PLAIN_TEXT","PYTHON","SVG","XML","KNOWN_TEXT_TYPES","Set","OCTET_STREAM","DEFAULT_STORAGE_NAME","Contents","constructor","options","this","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_storageName","contentsStorageName","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","name","description","storeName","version","async","_a","_b","_c","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","undefined","writable","ext","counter","Private","EMPTY_NB","stringify","length","key","setItem","toDir","slice","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","values","has","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","rename","URLExt","newUntitled","escape","atob","nb","parse","slashed","toDelete","keys","filter","startsWith","Promise","all","map","forgetPath","copies","Boolean","push","splice","id","normalizeCheckpoint","toString","checkpointID","parseInt","includes","fileUrl","PageConfig","response","fetch","ok","headers","indexOf","match","json","text","btoa","Uint8Array","arrayBuffer","reduce","apiURL","err","console","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","autoStart","provides","activate","app","requires","contents","router","req","filename","res","listCheckpoints","Response","post","checkpoint","restoreCheckpoint","status","createCheckpoint","delete","deleteCheckpoint","query","body","copyFrom","copy_from","copy","patch","newPath","put","save","IKernels","IKernelSpecs","kernelspecs","Kernels","kernels","kernelId","restart","shutdown","KernelSpecs","specs","ILicenses","Licenses","licenses","ISessions","Sessions","sessions","session","list","startNew","ISettings","settingsStorageName","Settings","settings","pluginPattern","pluginId","setting","raw","plugins","getAll","ITranslation","translation","Translation","locale"],"sourceRoot":""}